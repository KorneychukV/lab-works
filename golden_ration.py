import math


# Целевая функци
def f(x):
    return math.e ** x * math.sin(x)

# Точность вычисления
eps = 0.01
# Отрезок для поиска минимума функции
min_range = [-1, 0]
# Отрезок для поиска максимума функции
max_range = [2, 3]
x_min, x_max = 0, 0

# Поиск минимума функции
a = min_range[0]
b = min_range[1]
# Коэффициент сжатия отрезка
k = (math.sqrt(5) - 1) / 2
# Предполагаемы точки минимума
x1 = a + (1 - k) * (b - a)
x2 = a + k * (b - a)

while True:
    # Определение направления сжатия отрезка
    if f(x1) < f(x2):
        # Сжатие отрезка
        b = x2
        x2 = x1
        x1 = a + (1 - k) * (b - a)
    else:
        # Сжатие отрезка
        a = x1
        x1 = x2
        x2 = a + k * (b - a)

    # Если отрезок меньше заданной точности, то результат по центу отрезка
    if math.fabs(a-b) < eps:
        x_min = (a+b)/2
        y_min = f(x_min)
        break

# Поиск максимума функции
a = max_range[0]
b = max_range[1]
# Предполагаемы точки максимума
x1 = a + (1 - k) * (b - a)
x2 = a + k * (b - a)
while True:
    # Определение направления сжатия отрезка
    if f(x1) > f(x2):
        # Сжатие отрезка
        b = x2
        x2 = x1
        x1 = a + (1 - k) * (b - a)
    else:
        # Сжатие отрезка
        a = x1
        x1 = x2
        x2 = a + k * (b - a)

    # Если отрезок меньше заданной точности, то результат по центу отрезка
    if math.fabs(a-b) < eps:
        x_max = (a+b)/2
        y_max = f(x_max)
        break

# Вывод результата с точностью до тысячных
print(f"y_min={y_min:.3f}; x_min={x_min:.3f}")
print(f"y_max={y_max:.3f}; x_max={x_max:.3f}")